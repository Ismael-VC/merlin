(
	# TODO:

	-[x] Ignore spaces in input.
	-[x] Write input to buffer for parsing.
	-[ ] Check buffer is not overflowed.
	-[ ] Keep track of how many bytes I write to the buffer.
	-[ ] Parse each byte.
	-[ ] Store each byte.
)

%debug ( -- ) { .DEBUG #00 EQU }
%DBG ( -- ) { #010e DEO }
%DBG! ( -- ) { #010e DEO #010f DEO BRK }
%space ( -- ) { [ LIT2 \s -Console/write ] DEO }
%newline ( -- ) { [ LIT2 \n -Console/write ] DEO }
%bar ( -- ) { [ LIT2 "| -Console/write ] DEO }
%emit ( c -- ) { #18 DEO }
%NL { #0a }  %\n { 0a }
%SP { #20 }  %\s { 20 }

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1
|a0 @File &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|01 @DEBUG

|000

@input-buffer-pointer $2

|100 ( -> )
	{ "0080 $1 } STH2r parse-byte
	;here DUP2 SWP2 STA2
	;input-buffer .input-buffer-pointer STZ2
	<print-banner>
	<print-memory-usage>
	Repl/<print-first-prompt>
	;on-input .Console/vector DEO2
	BRK

BRK

@Repl
	&read ( buffer* -- )
		/<print-prompt>

	&eval


	&print


	&loop
		JMP2r

	&<print-first-prompt> ( -- )
		( this just skips the first newline, I will make it better later :P )
		;&prompt-start INC2 <print-string>
		;here LDA2 <print-short>
		;&prompt-end <print-string>
		JMP2r

	&<print-prompt> ( -- )
		;&prompt-start <print-string>
		;here LDA2 <print-short>
		;&prompt-end <print-string>
		JMP2r

	&prompt-start \n "փ \s "[ $1
	&prompt-end   "]> \s $1


@on-input ( -> )
	.Console/read DEI
	DUP SP NEQ ?{ POP BRK ( ignore ) }
	DUP NL EQU ?{
		.input-buffer-pointer LDZ2 STA
		.input-buffer-pointer LDZ2 INC2 .input-buffer-pointer STZ2
		;here DUP2 LDA2 INC2 SWP2 STA2 BRK }
	POP ( consume last newline )
	;input-buffer .input-buffer-pointer STZ2
	debug ?{
		DBG
		;input-buffer <print-memory> }
	parse-input-buffer
	Repl/read BRK

@<print-string> ( string* -- )
	LDAk .Console/write DEO
	INC2 LDAk ?<print-string>
	POP2 JMP2r

@<print-short> ( short* -- )
	SWP /<byte>
	&<byte> ( byte -- )
		DUP #04 SFT /<nibble>
	&<nibble> ( byte -- )
		#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
		JMP2r

@<print-memory-usage> ( -- )
	;here <print-short>
	;&used <print-string>
	;end ;here SUB2 <print-short>
	;&free <print-string>
	JMP2r

	&used \s "bytes \s "used, \s $1
	&free \s "bytes \s "free. \n \n $1

@<print-banner> ( -- )
	;&banner <print-string>
	JMP2r

	&banner "Monocycle Varvara/Uxn Concatenated Interpretive Uxntal Assembler REPL \s "(©MMXXIV \s "Ismael \s "Venegas \s "Castelló.) \n \n $1

@parse-byte ( str* -: val* )
	[ LIT2r 0000 ]
	&w ( str* `acc* -- val )
	LDAk parse-nibble INC #00 EQU ?{
		[ LITr 40 ] SFT2r LDAk parse-nibble [ LITr 00 ] STH
		ADD2r INC2 LDAk ?&w }
	POP2 STH2r JMP2r

@parse-nibble ( c -- val! )
	( dec ) [ LIT "0 ] SUB DUP #09 GTH ?{ JMP2r }
	( hex ) #27 SUB DUP #0f GTH ?{ JMP2r }
	( err ) POP #ff JMP2r

@<print-memory> ( addr* -- ) [
    STH2k
    DUP2 paddr space
    #0000
    &>loop-bytes
        ADD2k LDA <print-short>/<byte>
        DUP #0f AND
        DUP #07 NEQ ?{ space }
        #0f NEQ ?{
            space space
            bar
            OVR2 OVR2 ADD2 DUP2 #000f SUB2
            &>loop-chars
                LDAk
                DUPk SP GTH SWP #7f LTH AND ?{
                    POP LIT ". }
                emit
                INC2 GTH2k ?&>loop-chars
            POP2 POP2
            bar
            newline
            DUP2 INC2 STH2kr ADD2 paddr }
        space
        INC NEQk ?&>loop-bytes
    POP2 POP2 POP2r
    newline
    JMP2r
]

@parse-input-buffer ( -- )
	;input-buffer
	&loop
		LDA2k parse-byte
		INC2 INC2 LDAk DBG ?&loop
	POP2 JMP2r

@paddr ( addr* -- )  <print-short> space  JMP2r

@here

|ff7f @end

@input-buffer $80
