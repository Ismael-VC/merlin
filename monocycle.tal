( macros )
%VERSION { "00.03 }  %DATE { "05/05/07e8-17:14:0e }
%NAME { "Monocycle \s "CLI \s "REPL \t "Version \s VERSION \s 28 DATE 29 \n }
%DESCRIPTION {
  "Varvara/Uxn \s "Concatenated \s "Interpretive \s "Uxntal \s "JIT \s
  "Assembler. \n }
%AUTHOR { "©07e8 \s "Ismael \s "Venegas \s "Castelló, \s "MIT \s "License. \n }

%DBG ( -- ) { #010e DEO }
%HLT ( -- ) { #010f DEO BRK }
%DBG! ( -- ) { DBG HLT }
%<space> ( -- ) { [ LIT2 \s -Console/write ] DEO }
%<newline> ( -- ) { [ LIT2 \n -Console/write ] DEO }
%<emit> ( c -- ) { #18 DEO }
%\0 { 00 }  %\t { 09 }
%NL { #0a }  %\n { 0a }
%SP { #20 }  %\s { 20 }

( devices )
|00 @System
  &vector $2 &wst $1 &rst $1 &pad $4 &r $2 &g $2 &b $2 &debug $1 &halt $1

|10 @Console
  &vector $2 &read $1 &pad $4 &type $1 &write $1 &Error $1
|a0 @File
  &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length
  $2 &read $2 &write $2

( constants )
|0 @DEBUG ( set to |0 to enable debugging )

( zero page )
|0000 @input $80  @expression $80

( program )
|0100 ( -> )
  main
  ;meta #06 DEO2
  .Console/type DEI ?{
     ;Info/usage <pstr>
     #01 ;live STA }
  ;on-init-src .Console/vector DEO2
  BRK
  (
  ( set theme )
  #2ae7 .System/r DEO2
  #0a52 .System/g DEO2
  #2a37 .System/b DEO2

  ( set pointers )
  ;heap ;heap-ptr STA2
  ;input ;input-ptr STA2
  ;expression ;expression-ptr STA2

  ( init repl )
  ;banner <pstr>
  <pmem-usage>
  <print-prompt>
  ;REPL .Console/vector DEO2 )
  BRK

@meta $1
  ( name ) NAME
  ( desc ) DESCRIPTION
  ( auth ) AUTHOR
  ( date ) DATE
  ( exts ) 00

@REPL ( char -> )
  ( Read )
  .Console/read DEI
  DUP SP NEQ ?{ POP BRK ( ignore ) }
  DUP LIT "@ NEQ ?{ #01 ;&assemble STA POP BRK }
  DUP LIT "[ NEQ ?{ #00 ,&multi-line STR POP BRK }
  DUP LIT "] NEQ ?{ #01 ,&multi-line STR POP BRK }
  DUP LIT "( NEQ ?{ #00 ,&comment STR POP BRK }
  DUP LIT ") NEQ ?{ #01 ,&comment STR POP BRK }
  DUP NL EQU ?{
    [ LIT &comment 01 ] ?{
      POP BRK }
    ;input-ptr LDA2 STA
    ;input-ptr LDA2 INC2 ;input-ptr STA2  BRK }
  [ LIT &multi-line 01 ] ?{
    POP BRK }
  POP ( consume last newline )
  ( assemble-bytecode ) <assemble>
  ;REPL/assemble LDA ?{
    ( assemble expression return jump )
    #a0 ;expression-ptr LDA2 STA
    ;REPL/expression-return ;expression-ptr LDA2 INC2 STA2
    #2c ;expression-ptr LDA2 INC2 INC2 INC2 STA
    ( reset expression-ptr )
    ;expression ;expression-ptr STA2 }
  ;input ;input-ptr STA2 ( reset input-ptr )

  ( Eval )
  [ LIT &assemble $1 ] ?{
    ;expression JMP2 }
  &expression-return
  #00 ,&assemble STR
  .DEBUG ?{
    { \n "@input \s "& \s "@expression: \n $1 } STH2r <pstr>
    ;input <pmem> <newline> }
  ;input #0100 <mclr>

  ( Print )
  DBG
  .DEBUG ?{
    { \n "@heap: \n $1 } STH2r <pstr>
    ;heap <pmem> }

  ( Loop )
  <print-prompt> BRK

@banner [
   \s \s "█ "▄ \s \s NAME
   "▐ \s "█ \s "▌ \s DESCRIPTION
   \s "▀ "█ \s \s \s AUTHOR
   \s \s \s \s \s \s ( "Type \s ""help" \s "for \s "help. \s ) 
]

@<pmem-usage> ( -- )
  ;end ;heap-ptr LDA2 SUB2 <phex>
  ;&free <pstr>
  JMP2r
    &free [ \s "bytes \s "free. \n \0 ]

@<print-prompt> ( -- )
  ;&prompt-start <pstr>
  ;heap-ptr LDA2 <phex>
  ;&prompt-end <pstr>
  JMP2r
    &prompt-start \n "փ \s "[ \0
    &prompt-end   "]> \s \0

( library )
@assemble-bytecode ( -- val* )
  [ LIT2r 0000 ] ;input
  &>loop ( str* `acc* -: val* )
    LDAk parse-nibble INC #00 EQU ?{
      [ LITr 40 ] SFT2r LDAk parse-nibble [ LITr 00 ] STH
      ADD2r INC2
      [ LIT2 &count 0200 ] INC DUP2 ,&count STR2
      GTH ?{ #0200 ,&count STR2
        STHkr ;REPL/assemble LDA ?{
          ;expression-ptr LDA2 STA
          ;expression-ptr LDA2 INC2 ;expression-ptr STA2 !&continue }
        ;heap-ptr LDA2 STA
        ;heap-ptr LDA2 INC2 ;heap-ptr STA2 }
        &continue
    LDAk ?&>loop }
  POP2r POP2 JMP2r

@parse-nibble ( c -- val! )
  ( dec ) [ LIT "0 ] SUB DUP #09 GTH ?{ JMP2r }
  ( hex ) #27 SUB DUP #0f GTH ?{ JMP2r }
  ( Error ) POP #ff JMP2r

( assembler )
@on-init-src ( -> )
  .Console/read DEI ;src store-key ?{ BRK }
  ;on-init-dst .Console/vector DEO2
  BRK

@on-init-dst ( -> )
  .Console/read DEI ;dst store-key ?{ BRK }
  <assemble>
  ;live LDA ?{
    #80 ;halt LDA ORA #0f DEO
    BRK }
  ;Info/live <pstr>
  ;on-live .Console/vector DEO2
  BRK

@on-live ( -> )
  .Console/read DEI ;src store-key ?{ BRK }
  ( | cleanup )
  #00 ;halt STA
  #0000 ;length STA2
  ;mem/symbols ;<create-symbol>/ptr STA2
  ;Lambda/buf ;Lambda/ptr STA2
  #0000 ;<create-symbol>/count STA2
  <assemble>
  BRK

(
@|generics )

@<assemble> ( -- )
  ( scan ) #01 handle-pass ?&fail
  ( make ) #00 handle-pass ?&fail
  <write-rom>
  <write-sym>
  !<print-summary>
  &fail ( -- )
  ;dst/buf .File/name DEO2
  [ LIT2 01 -File/delete ] DEO
  JMP2r

@handle-pass ( scan -: Error )
  ;scan STA
  #0100 <set-head>
  #00 ;Lambda/count STA
  ;Info/reset <set-scope>
  ;src/buf handle-file ;halt LDA JMP2r

@handle-file ( f* -- )
  .File/name DEO2
  #0001 .File/length DEO2
  #0000
  &>s ( len* -- )
    ;&c feof ?&end
    INC2 [ LIT &c $1 ] handle-char !&>s
  &end ( len* -- )
  ORA ?{
    ;mem/include ;token/buf <scpy>
    ;Error/file <set-error> }
  JMP2r

@handle-char ( c -- )
  ;token store-key ?{ JMP2r }
  ;token/buf DUP2 parse-token !<sclr>

(
@|tokenizer )

@parse-token ( t* -- )
  LDAk ,&rune STR
  ;runes/end ;runes
  &>l ( -- )
    LDAk [ LIT &rune $1 ] NEQ ?{
      NIP2 INC2 LDA2
      ( * ) JMP2 }
    #0003 ADD2 GTH2k ?&>l
  POP2 POP2
  ( | non-runic )
  is-hex ?<write-rawhex>
  is-opcode ?<write-opcode>
  !lib/litjsi

@walk-comment ( t* -- )
  ;&c feof ?<sclr>
  [ LIT2 &c $1 28 ] NEQk ?{ ;Error/nested <set-error> }
  INC NEQ ?walk-comment
  !<sclr>

@lib &padabs INC2 get-any !<set-head>
  &padrel INC2 get-any ;head LDA2 ADD2 !<set-head>
  &toplab INC2 !<set-scope>
  &sublab INC2 get-sublabel !<create-symbol>
  &litrel #80 <write>
  &rawrel INC2 get-rel !<write>
  &litzep #80 <write>
  &rawzep INC2 get-ref NIP !<write>
  &litabs #a0 <write>
  &rawabs INC2 get-ref !<write-short>
  &litjci INC2 #20 !<write-call>
  &litjmi INC2 #40 !<write-call>
  &litjsi #60 !<write-call>
  &lithex INC2 !<write-lithex>
  &rawstr INC2 !<write-str>/
  &lambda POP2 !Lambda/pop
  &inc INC2k ;mem/include STH2k <scpy>
  <sclr>
  STH2r !handle-file
  &ignore POP2 JMP2r

(
@|primitives )

@<write-str> ( str* -: )
  LDAk <write>
  INC2 & LDAk ?<write-str>
  POP2 JMP2r

@<write-opcode> ( str* -: )
  find-opcode !<write>

@<write-lithex> ( str* -: )
  DUP2 slen NIP
  ( LIT ) DUP #04 EQU #50 SFT #80 ORA <write>
  !<write-hex>

@<write-rawhex> ( str* -: )
  DUP2 slen NIP
  ( >> )

@<write-hex> ( str* len -- )
  DUP #02 NEQ ?{ POP shex NIP !<write> }
  #04 NEQ ?{ shex !<write-short> }
  POP2 ;Error/number !<set-error>

@<write-call> ( str* opc -: )
  <write>
  get-ref ;head LDA2 INC2 INC2 SUB2
  ( >> )

@<write-short> ( short* -: )
  SWP <write>
  ( >> )

@<write> ( byte -: )
  DUP ;head LDA2 INC2k STH2
  ;rom ADD2 STA
  <set-length>
  STH2r
  ( >> )

@<set-head> ( v* -: )
  ;head STA2
  JMP2r

@<set-error> ( name* -- )
  ;Error <pstr>
  <pstr>
  #2018 DEO
  ;token/buf <pstr>
  ;Info/in <pstr>/
  ;scope <pstr>/
  #0a18 DEO
  #01 ;halt STA
  JMP2r

@<set-length> ( byte -- )
  ?{ JMP2r }
  ;scan LDA ?{ JMP2r }
  ;head LDA2
  ( ) DUP2 OVR ?{ ;Error/zeropage <set-error> }
  ( ) #8000 LTH2 ?{ ;Error/length <set-error> }
  ;length STA2
  JMP2r

(
@|output )

@<write-rom> ( -: )
  ;dst/buf .File/name DEO2
  ;length LDA2 #00ff SUB2 .File/length DEO2
  ;rom/output .File/write DEO2
  JMP2r

@<write-sym> ( -- )
  ;dst/buf DUP2 scap/ ;Info/sym-ext OVR2 <scpy>
  SWP2 .File/name DEO2
  ;mem/symbols
  &>w ( -- )
    ( addr ) #0002 .File/length DEO2
    DUP2 .File/write DEO2
    ( name ) #0003 ADD2 DUP2 slen INC2 STH2k .File/length DEO2
    DUP2 .File/write DEO2
    STH2r ADD2 DUP2 #0003 ADD2 LDA ?&>w
  POP2 #00 ROT ROT STA
  JMP2r

@<print-summary> ( -- )
  ( | Print summary )
  ;<create-symbol>/ptr LDA2 ;mem/symbols
  &>l ( -- )
    INC2k INC2 LDA ?&skip
    #0003 ADD2 LDAk [ LIT "A ] SUB #1a LTH ?&skip
    LDAk [ LIT 28 ] EQU ?&skip
    DUP2 ;Info/reset scmp ?&skip
    ;Info/unused <pstr>/
    DUP2 <pstr>/
    #0a18 DEO
    &skip scap/ INC2 GTH2k ?&>l
  POP2 POP2
  ( | result )
  ;Info/assembled <pstr>/
  ;dst/buf <pstr>/
  ( | length )
  ;Info/in <pstr>/
  ;length LDA2 #00ff SUB2 <pdec>
  ;Info/bytes <pstr>/
  ;<create-symbol>/count LDA2 <pdec>
  ;Info/labels !<pstr>/

(
@|labels )

@get-sublabel ( name* -- sublabel* )
  DUP2 slen ;sublabel slen ADD2 #0030 LTH2 ?{ ;Error/sublabel !<set-error> }
  [ LIT2 &ptr $2 ] <scpy>
  ;sublabel JMP2r

@<set-scope> ( t* -- )
  ( | copy scope until sublabel )
  DUP2 [ LIT2r =scope ]
  &>w ( -- )
    LDAk [ LIT "/ ] EQU ?&end
    LDAk STHkr STA
    INCr INC2 LDAk ?&>w
  &end POP2 #00 STHr STA
  ( | prepare sublabel pointer )
  ;scope ;sublabel <scpy>
  [ LIT2 "/ 00 ] ;sublabel scap/
  ( ptr ) INC2k ,get-sublabel/ptr STR2
  ( cap ) STA2
  ( >> )

@<create-symbol> ( name* -- )
  ;scan LDA ?{ POP2 JMP2r }
  is-hex ?&invalid
  is-opcode ?&invalid
  is-runic ?&invalid
  DUP2 find-symbol INC2 ORA ?&not-unique
  ( addr* ) ;head LDA2 [ LIT2 &ptr =mem/symbols ] STH2k INC2r INC2r STA2
  ( refs ) #00 STH2kr INC2r STA
  ( name[] ) DUP2 STH2kr <scpy>
  slen STH2r ADD2 INC2 ,&ptr STR2
  [ LIT2 &count $2 ] INC2 ,&count STR2
  JMP2r
  &invalid ( name* -- )
  POP2 ;Error/symbol !<set-error>
  &not-unique ( name* -- )
  POP2 ;Error/duplicate !<set-error>

@find-symbol ( name* -- <addr>* )
  ,&t STR2
  ;<create-symbol>/ptr LDA2 ;mem/symbols
  &>l ( -- )
    EQU2k ?&end
    #0003 ADD2 DUP2 [ LIT2 &t $2 ] scmp ?&found
    scap/ INC2 GTH2k ?&>l
  &end POP2 POP2 #ffff JMP2r
  &found ( symbols* -- <addr>* )
  #0003 SUB2 NIP2 JMP2r

@get-any ( str* -- value* )
  is-hex ?shex
  !get-ref/eager

@get-ref ( token* -- addr* )
  LDAk [ LIT "{ ] NEQ ?{ POP2 Lambda/push }
  ;scan LDA ?&scan
  &eager ( -- )
  LDAk [ LIT "/ ] NEQ ?{ INC2 get-sublabel }
  LDAk [ LIT "& ] NEQ ?{ INC2 get-sublabel }
  find-symbol INC2k #0000 EQU2 ?{
    INC2k INC2 LDAk INC ROT ROT STA
    LDA2 JMP2r }
  ;Error/reference <set-error>
  &scan JMP2r

@get-rel ( label* -- distance )
  get-ref ;head LDA2 INC2 INC2 SUB2
  ( ) DUP2 #0080 ADD2 POP ?{ NIP JMP2r }
  ( ) ;scan LDA ?{ ;Error/distance <set-error> }
  POP2 #ff JMP2r

@Lambda
  &push ( -- name* )
  [ LIT &count $1 ] INCk ,&count STR
  DUP [ LIT2 &ptr =&buf ] INC2k ,&ptr STR2
  STA
  ( >> )
  &name ( id -- str* )
  #21 ADD ,&id STR
  ;&sym JMP2r
  &pop ( -- )
  ,&ptr LDR2 #0001 SUB2 LDAk /name <create-symbol>
  ,&ptr STR2
  JMP2r
  &sym cebb &id $2

(
@|helpers )

@is-hex ( str* -- str* f )
  DUP2
  &>w ( -- )
    LDAk chex INC ?{ POP2 #00 JMP2r }
    INC2 LDAk ?&>w
  POP2 #01 JMP2r

@is-opcode ( str* -- str* f )
  DUP2 find-opcode ?{ DUP2 ;opcodes/brk !scmp3 }
  #01 JMP2r

@is-runic ( str* -- str* f )
  LDAk ,&rune STR
  ;runes/end ;runes
  &>l ( -- )
    LDAk [ LIT &rune $1 ] EQU ?&end
    #0003 ADD2 GTH2k ?&>l
  &end NEQ2 JMP2r

@find-opcode ( name* -- byte )
  STH2
  #2000
  &>l ( -- )
    #00 OVR #03 MUL ;opcodes ADD2 STH2kr scmp3 ?&on-found
    INC GTHk ?&>l
  POP2 POP2r #00 JMP2r
  &on-found ( `name* bounds* -- byte )
  ( add keep mode to LIT ) NIP DUP #00 EQU #70 SFT ORA
  ( move to modes ) STH2r #0003 ADD2
  ( keep flag ) [ LITr 00 ]
  &>w ( -- )
    LDAk #20 OVR [ LIT "2 ] EQU ?&end
    DUP ADD OVR [ LIT "r ] EQU ?&end
    DUP ADD OVR [ LIT "k ] EQU ?&end
    DUP ADD OVR #00 EQU ?&end
    ;Error/opcode <set-error>
    &end STH POP
    ORAr INC2 LDAk ?&>w
  POP2 STHr ADD JMP2r

(
@|stdlib )
@<phex> ( short* -- )
  &short SWP /byte
  &byte ( byte -- ) DUP #04 SFT /nibble
  &nibble ( byte -- ) #0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
  JMP2r

@<mclr> ( src* len* -- )
  OVR2 ADD2 SWP2
  &>loop ( -- )
    LITr 00 STH2k STAr
    INC2 GTH2k ?&>loop
  POP2 POP2 JMP2r

@<pmem> ( addr* len* -- )
  STH2k DUP2 <phex> <space> <space> #0000
  &>loop-bytes ( addr* i* | addr* -- )
    ADD2k LDA <phex>/byte
    DUP #0f AND DUP #07 NEQ ?{ <space> }
    #0f NEQ ?{
      <space> <space> [ LIT2 "| -Console/write ] DEO
      ADD2k DUP2 INC2 SWP2 #000f SUB2
      &>loop-chars
        LDAk DUPk SP GTH SWP #7f LTH AND ?{
          POP LIT ". }
        <emit> INC2 GTH2k ?&>loop-chars
      POP2 POP2
      [ LIT2 "| -Console/write ] DEO <newline> DUP2 INC2 STH2kr ADD2
      <phex> <space> }
    <space> INC NEQk ?&>loop-bytes
  POP2 POP2 POP2r <newline> JMP2r

@feof ( addr* -: f )
  .File/read DEO2
  .File/success DEI2 #0000 EQU2 JMP2r


(
    @store-key

  Store a char into a counted buffer and returns zero, a char < 0x21 resets the
  counted buffer length to zero and return the length. If the input string is 
  longer than 0x30 a buffer overflow Error is shown.

  # Arguments
  - key: char
  - buffer*: counted buffer.

  # Examples
    > @foo &len $1 buf $30
    > [ LIT "f ] ;foo store-key
    > [ LIT "o ] ;foo store-key
    > [ LIT "o ] ;foo store-key
    > ;foo <pmem>
    0f20  03 66 6f 6f 00 00 00 00  00 00 00 00 00 00 00 00  |.foo............|
    ⋮
    > ( newline ) NL ;foo store-key
    > <psts>
    WST 00 00 00 00 00 00 00 00 00 00 00 00|00 00 00 03 <
    RST 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|<
    > ;foo <pmem>
    0f20  00 66 6f 6f 00 00 00 00  00 00 00 00 00 00 00 00  |.foo............|
    ⋮
)
@store-key ( key buffer* -- proc ) [
  ROTk NIP NIP #21 LTH ?&eval
  LDAk #2f EQU ?&overflow
  ( write char ) STH2
  #00 STH2kr LDAk #00 SWP ADD2 INC2 STA2
  ( incr len ) STH2r LDAk INC ROT ROT STA
  #00 JMP2r

    &overflow ( key buffer* -- proc )
      ;Error/overflow <set-error>

    &eval ( key buffer* -- proc )
      ROT POP LDAk #00 SWP2 STA
      JMP2r
]

@scap ( str* -: end* )
  INC2 & LDAk ?scap
  JMP2r

@slen ( str* -: len* )
  DUP2 scap/ SWP2 SUB2 JMP2r

@scmp ( a* b* -- f )
  STH2
  &l ( -- )
  LDAk ?{
    &d LDA LDAr STHr EQU JMP2r }
  LDAk LDAkr STHr NEQ ?&d
  INC2 INC2r !&l

@scmp3 ( a* b* -- f )
  STH2
  LDAkr LDAk STHr NEQ ?{ INC2r INC2 }
  LDA2r LDA2 STH2r EQU2 JMP2r

@chex ( c -: <val> )
  [ LIT "0 ] SUB DUP #0a LTH ?&end
  #27 SUB DUP #10 LTH ?&end
  POP #ff &end JMP2r

@shex ( str* -: value* )
  [ LIT2r 0000 ]
  &>w ( `i* -- )
    ( acc ) [ LITr 40 ] SFT2r
    ( res ) LDAk chex [ LITr 00 ] STH
    ADD2r INC2 LDAk ?&>w
  POP2 STH2r JMP2r

(
    @<scpy> ( src* dnt* -- )

  Copy a string into a buffer.

  # Arguments
  - `src*`: Source string.
  - `dst*`: Destinatdon buffer.

  # Examples
    > @foo "this 20 "is 20 "a 20 "test 0a 00
    > @bar $10
    > ;foo <pmem>
    0f3e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    0f4e  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ⋮
    > ;foo ;bar <scpy>
    > ;foo <pmem>
    0f3e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    0f4e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    ⋮
)
@<scpy> ( src* dst* -: ) [
  STH2
  &>w ( src* `dst* -- )
    LDAk #00 STH2kr STA2
    INC2r INC2 LDAk ?&>w
  POP2 POP2r JMP2r
]

(
    @<sclr> ( str* -- )

  Clears a string data by filling it with zeros.

  # Arguments
  - `str*`:

  # Examples
    > @foo "this 20 "is 20 "a 20 "test 0a $1
    > ;foo <pmem>
    0f4d  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    ⋮
    > ;foo <sclr>
    > ;foo <pmem>
    0f4d  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ⋮
)
@<sclr> ( str* -- ) [
  #00 ROT ROT
  &>w ( -- )
    STAk INC2 LDAk ?&>w
  STA
  JMP2r
]

(
      @<pstr> ( str* -- )

    Print a null terminated string.

    # Arguments
    - `str*`: Address of the first character in the string.

    # Examples
    > @hello "Hello 20 "World! 0a $1
    > ;hello <pstr>
    Hello World!
    > { "Hola 20 "Mundo! 0a $1 } STH2r <pstr>
    Hola Mundo!
    > @empty $1
    > ;empty <pstr>/ ( handle empty strings correctly )
)
@<pstr> ( str* -: ) [
  LDAk #18 DEO
  INC2 & LDAk ?<pstr>
  POP2 JMP2r
]

(
    @<pdec> ( short* -- )

  Print an hexadecimal short to decimal base.

  # Arguments
  - `short*`: Hexadecimal number to be printed in base 10.

  # Examples
    > #ffff <pdec>
    65535
    > #0080 <pdec>
    128
    > #0000 <pdec>
    0
)
@<pdec> ( short* -- ) [
  DUP2 #0000 NEQ2 ?{
    [ LIT "0 ] #18 DEO
    POP2 JMP2r }
  #2710 [ LIT2r 00fb ]
  &>w ( -- )
    DIV2k #000a DIV2k MUL2 SUB2 SWPr EQUk OVR STHkr EQU AND ?{
      DUP [ LIT "0 ] ADD #18 DEO
      INCr }
    POP2 #000a DIV2 SWPr INCr STHkr ?&>w
  POP2r POP2 POP2 JMP2r
]

(
@|assets )

@Info [
  &usage "usage: 20 "drifblim.rom 20 "in.tal 20 "out.rom 0a $1
  &unused "-- 20 "Unused: 20 $1
  &reset "on-reset $1
  &assembled "Assembled 20 $1
  &in 20 "in 20 $1
  &bytes 20 "bytes( $1
  &labels 20 "labels). 0a $1
  &sym-ext ".sym $1
  &live "Listening.. 0a $1
]

@Error [
  "!! 20 "Error: 20 $1
  &file "File $1
  &duplicate "Duplicate $1
  &number "Number $1
  &length "Length $1
  &reference "Reference $1
  &distance "Distance $1
  &symbol "Symbol $1
  &token "Token $1
  &sublabel "Sublabel $1
  &opcode "Opcode $1
  &nested "Nested $1
  &zeropage "Zero-page $1
  &overflow "Overflow $1
]

@opcodes [
  "LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
  "EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
  "LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
  "ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
  &brk "BRK 
]

@runes [
  "| =lib/padabs "$ =lib/padrel
  "} =lib/lambda "( =walk-comment
  "@ =lib/toplab "& =lib/sublab
  ", =lib/litrel "_ =lib/rawrel
  ". =lib/litzep "- =lib/rawzep
  "; =lib/litabs "= =lib/rawabs
  "? =lib/litjci "! =lib/litjmi
  "[ =lib/ignore "] =lib/ignore
  "# =lib/lithex "" =lib/rawstr
  "~ =lib/inc    &end
]

(
@|mem )
( pointers )
@input-ptr $2
@heap-ptr $2
@expression-ptr $2

@Lambda/buf $100

@mem ( buffers ) [
  &include $30
  &symbols ( addr*, refs, name[], 00 )
]

@assembler-vars [
  @src &len $1 &buf $30
  @dst &len $1 &buf $30
  @token $1 &buf $30
  @scope $30
  @sublabel $30
  @live $1
  @scan $1
  @head $2
  @halt $1
  @length $2
]

@foo "1337 $1
@bar $10

@main ( -- ) [
  ;foo shex <phex> <newline>
	HLT
]

( heap )
@heap

|8000 @rom $100 &output
|ffff @end
