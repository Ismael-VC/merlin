(
	# TODO:

	-[x] Ignore spaces in input.
	-[x] Write input to buffer for parsing.
	-[ ] Check buffer is not overflowed.
	-[ ] Keep track of how many bytes I write to the buffer.
	-[ ] Parse each byte.
	-[ ] Store each byte.
)

%NOT ( -- ) { #00 EQU }
%debug ( -- ) { .DEBUG NOT }
%DBG ( -- ) { #010e DEO }
%DBG! ( -- ) { #010e DEO #010f DEO BRK }
%space ( -- ) { [ LIT2 \s -Console/write ] DEO }
%newline ( -- ) { [ LIT2 \n -Console/write ] DEO }
%bar ( -- ) { [ LIT2 "| -Console/write ] DEO }
%emit ( c -- ) { #18 DEO }
%NL { #0a }  %\n { 0a }
%SP { #20 }  %\s { 20 }

|00 @System &vector $2 &wst $1 &rst $1 &pad $4 &r $2 &g $2 &b $2 &debug $1 &halt $1
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

|00 @DEBUG

|000

@input-buffer-pointer $2
@here-current $2
@here-pointer $2

|100 ( -> )
    #3ae8 .System/r DEO2
    #0a53 .System/g DEO2
    #2927 .System/b DEO2
	;here .here-pointer STZ2
	;input-buffer .input-buffer-pointer STZ2
	<print-banner>
	<print-memory-usage>
	Repl/<print-first-prompt>
	;on-input .Console/vector DEO2
	BRK

BRK

@Repl
	&read ( buffer* -- )
		/<print-prompt>

	&eval


	&print


	&loop
		JMP2r

	&<print-first-prompt> ( -- )
		( this just skips the first newline, I will make it better later :P )
		;&prompt-start INC2 <print-string>
		.here-pointer LDZ2 <print-short>
		;&prompt-end <print-string>
		JMP2r

	&<print-prompt> ( -- )
		;&prompt-start <print-string>
		.here-pointer LDZ2 <print-short>
		;&prompt-end <print-string>
		JMP2r

	&prompt-start \n "փ \s "[ $1
	&prompt-end   "]> \s $1


@on-input ( -> )
	.Console/read DEI
	DUP SP NEQ ?{ POP BRK ( ignore ) }
	DUP LIT "( NEQ ?{ #00 ,&comment STR POP BRK }
	DUP LIT ") NEQ ?{ #01 ,&comment STR POP BRK }
	DUP NL EQU ?{
		[ LIT &comment 01 ] ?{
			POP BRK }
		.input-buffer-pointer LDZ2 STA
		.input-buffer-pointer LDZ2 INC2 .input-buffer-pointer STZ2  BRK }
	POP ( consume last newline )
	assemble-bytecode
	#6c .here-pointer LDZ2 STA
	.here-pointer LDZ2 INC2 .here-pointer STZ2
	;input-buffer .input-buffer-pointer STZ2
	.here-current LDZ2 JSR2
	;input-buffer #0080 <mclr>
	DBG
	debug ?{
		{ \n "@here: \n $1 } STH2r <print-string>
		;here <print-memory> }
	Repl/read BRK

@<print-string> ( string* -- )
	LDAk .Console/write DEO
	INC2 LDAk ?<print-string>
	POP2 JMP2r

@<print-short> ( short* -- )
	SWP /<byte>
	&<byte> ( byte -- )
		DUP #04 SFT /<nibble>
	&<nibble> ( byte -- )
		#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
		JMP2r

@<mclr> ( src* len* -- )
	OVR2 ADD2 SWP2
	&l ( -- )
		LITr 00 STH2k STAr
		INC2 GTH2k ?&l
	POP2 POP2 JMP2r

@<print-memory-usage> ( -- )
	;here <print-short>
	;&used <print-string>
	;end ;here SUB2 <print-short>
	;&free <print-string>
	JMP2r

	&used \s "bytes \s "used, \s $1
	&free \s "bytes \s "free. \n \n $1

@<print-banner> ( -- )
	;&banner <print-string>
	JMP2r

	&banner "
		"Monocycle \s "CLI \s "REPL \s "Version \s "0.1 \n
		"Varvara/Uxn \s "Concatenated \s "Interpretive \s
		"Uxntal \s "JIT \s "Assembler \n
		"(© \s "MMXXIV \s "Ismael \s "Venegas \s "Castelló, \s
		"MIT \s "License.) \n $1

@assemble-bytecode ( -: val* )
		.here-pointer LDZ2 .here-current STZ2
        [ LIT2r 0000 ] ;input-buffer
        &w ( str* `acc* -: val* )
        LDAk parse-nibble INC #00 EQU ?{
                [ LITr 40 ] SFT2r LDAk parse-nibble [ LITr 00 ] STH
                ADD2r INC2
                [ LIT2 &count 0200 ] INC DUP2 ,&count STR2
                GTH ?{ #0200 ,&count STR2
                STHkr .here-pointer LDZ2 STA
                .here-pointer LDZ2 INC2 .here-pointer STZ2 }
                LDAk ?&w }
        POP2r POP2 JMP2r

@parse-nibble ( c -- val! )
	( dec ) [ LIT "0 ] SUB DUP #09 GTH ?{ JMP2r }
	( hex ) #27 SUB DUP #0f GTH ?{ JMP2r }
	( err ) POP #ff JMP2r

@<print-memory> ( addr* -- ) [
    STH2k
    DUP2 paddr space
    #0000
    &>loop-bytes
        ADD2k LDA <print-short>/<byte>
        DUP #0f AND
        DUP #07 NEQ ?{ space }
        #0f NEQ ?{
            space space
            bar
            OVR2 OVR2 ADD2 DUP2 #000f SUB2
            &>loop-chars
                LDAk
                DUPk SP GTH SWP #7f LTH AND ?{
                    POP LIT ". }
                emit
                INC2 GTH2k ?&>loop-chars
            POP2 POP2
            bar
            newline
            DUP2 INC2 STH2kr ADD2 paddr }
        space
        INC NEQk ?&>loop-bytes
    POP2 POP2 POP2r
    newline
    JMP2r
]

@paddr ( addr* -- )  <print-short> space  JMP2r

@here

|ff7f @end

@input-buffer $80
