(
@|stdlib )
@<phex> ( short* -- )
  &short SWP /byte
  &byte ( byte -- ) DUP #04 SFT /nibble
  &nibble ( byte -- ) #0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
  JMP2r

@<mclr> ( src* len* -- )
  OVR2 ADD2 SWP2
  &>loop ( -- )
    LITr 00 STH2k STAr
    INC2 GTH2k ?&>loop
  POP2 POP2 JMP2r

@<pmem> ( addr* len* -- )
  STH2k DUP2 <phex> <space> <space> #0000
  &>loop-bytes ( addr* i* | addr* -- )
    ADD2k LDA <phex>/byte
    DUP #0f AND DUP #07 NEQ ?{ <space> }
    #0f NEQ ?{
      <space> <space> [ LIT2 "| -Console/write ] DEO
      ADD2k DUP2 INC2 SWP2 #000f SUB2
      &>loop-chars
        LDAk DUPk SP GTH SWP #7f LTH AND ?{
          POP LIT ". }
        <emit> INC2 GTH2k ?&>loop-chars
      POP2 POP2
      [ LIT2 "| -Console/write ] DEO <newline> DUP2 INC2 STH2kr ADD2
      <phex> <space> }
    <space> INC NEQk ?&>loop-bytes
  POP2 POP2 POP2r <newline> JMP2r

@feof ( addr* -: f )
  .File/read DEO2
  .File/success DEI2 #0000 EQU2 JMP2r


(
    @store-key

  Store a char into a counted buffer and returns zero, a char < 0x21 resets the
  counted buffer length to zero and return the length. If the input string is 
  longer than 0x30 a buffer overflow Error is shown.

  # Arguments
  - key: char
  - buffer*: counted buffer.

  # Examples
    > @foo &len $1 buf $30
    > [ LIT "f ] ;foo store-key
    > [ LIT "o ] ;foo store-key
    > [ LIT "o ] ;foo store-key
    > ;foo <pmem>
    0f20  03 66 6f 6f 00 00 00 00  00 00 00 00 00 00 00 00  |.foo............|
    ⋮
    > ( newline ) NL ;foo store-key
    > <psts>
    WST 00 00 00 00 00 00 00 00 00 00 00 00|00 00 00 03 <
    RST 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|<
    > ;foo <pmem>
    0f20  00 66 6f 6f 00 00 00 00  00 00 00 00 00 00 00 00  |.foo............|
    ⋮
)
@store-key ( key buffer* -- proc ) [
  ROTk NIP NIP #21 LTH ?&eval
  LDAk #2f EQU ?&overflow
  ( write char ) STH2
  #00 STH2kr LDAk #00 SWP ADD2 INC2 STA2
  ( incr len ) STH2r LDAk INC ROT ROT STA
  #00 JMP2r

    &overflow ( key buffer* -- proc )
      ;Error/overflow <set-error>

    &eval ( key buffer* -- proc )
      ROT POP LDAk #00 SWP2 STA
      JMP2r
]

@scap ( str* -: end* )
  INC2 & LDAk ?scap
  JMP2r

@slen ( str* -: len* )
  DUP2 scap/ SWP2 SUB2 JMP2r

@scmp ( a* b* -- f )
  STH2
  &l ( -- )
  LDAk ?{
    &d LDA LDAr STHr EQU JMP2r }
  LDAk LDAkr STHr NEQ ?&d
  INC2 INC2r !&l

@scmp3 ( a* b* -- f )
  STH2
  LDAkr LDAk STHr NEQ ?{ INC2r INC2 }
  LDA2r LDA2 STH2r EQU2 JMP2r

@chex ( c -: <val> )
  [ LIT "0 ] SUB DUP #0a LTH ?&end
  #27 SUB DUP #10 LTH ?&end
  POP #ff &end JMP2r

(
    @shex ( str* -- value* )

	Parse a string in hexadecimal format and return it's value as a short.

	# Arguments
	- `str*`: String to be parsed.

	# Returns
	- `value*`: Parsed value from string.

	# Examples
	  > @foo "1337 $1
		> ;foo <shex> 
		> <psts>
		WST 00 00 00 00 00 00 00 00 00 00 00 00 00 00|13 37 <
    RST 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|<
		> <phex>
		1337
)
@shex ( str* -: value* )
  [ LIT2r 0000 ]
  &>w ( `i* -- )
    ( acc ) [ LITr 40 ] SFT2r
    ( res ) LDAk chex [ LITr 00 ] STH
    ADD2r INC2 LDAk ?&>w
  POP2 STH2r JMP2r

(
	  @<psts> ( -- )
	
	Print the Working stack and the Return stack.

	# Examples
	  > #1234
	  > <psts>
		WST 00 00 00 00 00 00 00 00 00 00 00 00 00 00|12 34 <
    RST 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|< 
)
@<psts> ( -- ) [ DBG ]

(
    @<scpy> ( src* dnt* -- )

  Copy a string into a buffer.

  # Arguments
  - `src*`: Source string.
  - `dst*`: Destinatdon buffer.

  # Examples
    > @foo "this 20 "is 20 "a 20 "test 0a 00
    > @bar $10
    > ;foo <pmem>
    0f3e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    0f4e  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ⋮
    > ;foo ;bar <scpy>
    > ;foo <pmem>
    0f3e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    0f4e  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    ⋮
)
@<scpy> ( src* dst* -: ) [
  STH2
  &>w ( src* `dst* -- )
    LDAk #00 STH2kr STA2
    INC2r INC2 LDAk ?&>w
  POP2 POP2r JMP2r
]

(
    @<sclr> ( str* -- )

  Clears a string data by filling it with zeros.

  # Arguments
  - `str*`:

  # Examples
    > @foo "this 20 "is 20 "a 20 "test 0a $1
    > ;foo <pmem>
    0f4d  74 68 69 73 20 69 73 20  61 20 74 65 73 74 0a 00  |this.is.a.test..|
    ⋮
    > ;foo <sclr>
    > ;foo <pmem>
    0f4d  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ⋮
)
@<sclr> ( str* -- ) [
  #00 ROT ROT
  &>w ( -- )
    STAk INC2 LDAk ?&>w
  STA
  JMP2r
]

(
      @<pstr> ( str* -- )

    Print a null terminated string.

    # Arguments
    - `str*`: Address of the first character in the string.

    # Examples
    > @hello "Hello 20 "World! 0a $1
    > ;hello <pstr>
    Hello World!
    > { "Hola 20 "Mundo! 0a $1 } STH2r <pstr>
    Hola Mundo!
    > @empty $1
    > ;empty <pstr>/ ( handle empty strings correctly )
)
@<pstr> ( str* -: ) [
  LDAk #18 DEO
  INC2 & LDAk ?<pstr>
  POP2 JMP2r
]

(
    @<pdec> ( short* -- )

  Print an hexadecimal short to decimal base.

  # Arguments
  - `short*`: Hexadecimal number to be printed in base 10.

  # Examples
    > #ffff <pdec>
    65535
    > #0080 <pdec>
    128
    > #0000 <pdec>
    0
)
@<pdec> ( short* -- ) [
  DUP2 #0000 NEQ2 ?{
    [ LIT "0 ] #18 DEO
    POP2 JMP2r }
  #2710 [ LIT2r 00fb ]
  &>w ( -- )
    DIV2k #000a DIV2k MUL2 SUB2 SWPr EQUk OVR STHkr EQU AND ?{
      DUP [ LIT "0 ] ADD #18 DEO
      INCr }
    POP2 #000a DIV2 SWPr INCr STHkr ?&>w
  POP2r POP2 POP2 JMP2r
]